<script>
        // --- CONFIGURATION ---
        // Votre cl√© API fournie
        const TMDB_API_KEY = 'a8b8177cf88f3604d3df137469205626'; 
        let allFilms = [];
        let hideWatchedMode = false;
        let showOnlyWatchedMode = false;

        // --- FONCTIONS API TMDB ---

        // Fonction unique et optimis√©e pour r√©cup√©rer le poster
        async function fetchTMDbPoster(title, year) {
            try {
                // On nettoie le titre pour la recherche (enl√®ve les caract√®res sp√©ciaux parfois g√™nants)
                const cleanTitle = title.trim();
                
                // On demande les r√©sultats en fran√ßais
                const url = `https://api.themoviedb.org/3/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(cleanTitle)}&year=${year}&language=fr-FR`;
                
                const response = await fetch(url);
                const data = await response.json();

                if (data.results && data.results.length > 0) {
                    // On prend le premier r√©sultat qui a une image
                    const bestMatch = data.results.find(m => m.poster_path) || data.results[0];
                    if (bestMatch.poster_path) {
                        return `https://image.tmdb.org/t/p/w500${bestMatch.poster_path}`;
                    }
                }
            } catch (error) {
                console.error(`Erreur TMDb pour ${title}:`, error);
            }
            return null;
        }

        // Cette fonction est appel√©e si l'image par d√©faut √©choue ou si on force le chargement API
        function tryTMDbPoster(imgElement, title, year) {
            // √âvite une boucle infinie si l'API √©choue aussi
            imgElement.onerror = null; 

            fetchTMDbPoster(title, year).then(posterUrl => {
                if (posterUrl) {
                    imgElement.src = posterUrl;
                    imgElement.style.opacity = '1';
                } else {
                    // Si aucune image trouv√©e, on cache l'image et on affiche le titre texte
                    imgElement.style.display = 'none';
                    // On recr√©e le titre texte √† la place
                    const container = imgElement.parentElement;
                    container.innerHTML = `<span style="color: #d4af37; font-weight: bold; font-size: 1.5em; line-height: 1.3; padding: 10px; text-align: center; display: block;">${title}</span>`;
                }
            });
        }

        // --- GESTION DES DONN√âES ---

        function loadFilmsFromStorage() {
            try {
                const stored = localStorage.getItem('cinema_films');
                if (stored) {
                    allFilms = JSON.parse(stored);
                    // Tri par ann√©e d√©croissante par d√©faut
                    allFilms.sort((a, b) => parseInt(b.year) - parseInt(a.year));
                    displayFilms(allFilms);
                    updateStats();
                } else {
                    updateStats();
                }
            } catch (error) {
                console.error('Erreur chargement storage:', error);
                allFilms = [];
            }
        }

        function saveFilmsToStorage() {
            try {
                localStorage.setItem('cinema_films', JSON.stringify(allFilms));
            } catch (error) {
                console.error('Erreur sauvegarde:', error);
            }
        }

        function parseFilmsFromText(text) {
            const lines = text.split('\n').filter(line => line.trim());
            return lines.map(line => {
                const parts = line.split('\t').map(p => p.trim());
                
                if (parts.length < 2) return null; // S√©curit√© minimale
                
                const title = parts[0];
                const year = parts[1];
                const duration = parts[2] || '';
                const awardText = parts[3] || '';
                const genreText = parts[4] || '';
                const platform = parts[5] || '';
                const posterUrl = parts[6] || '';
                
                const genres = genreText ? genreText.split(',').map(g => g.trim()).filter(g => g) : [];
                const awards = awardText ? [awardText] : []; // Simplification bas√©e sur votre format
                
                return {
                    title, year, duration, awards, genres, platform, posterUrl,
                    watched: false
                };
            }).filter(f => f && f.title);
        }

        // --- AFFICHAGE ---

        function displayFilms(films) {
            const list = document.getElementById('filmsList');

            if (films.length === 0) {
                list.innerHTML = '<div class="empty-message">Aucun film ne correspond √† vos crit√®res</div>';
                return;
            }

            list.innerHTML = films.map((film, index) => {
                // Trouver l'index r√©el dans allFilms pour les actions (delete, toggle)
                const realIndex = allFilms.indexOf(film);
                const bgColor = generateColorFromTitle(film.title);
                
                // Logique Image : 
                // 1. Si pas d'URL ou URL en http (bloqu√© par GitHub), on force l'appel API via l'image vide + onerror
                // 2. Sinon on utilise l'URL HTTPS existante
                let imgTag = '';
                
                // V√©rification stricte : si c'est du HTTP simple, on consid√®re que c'est invalide pour GitHub Pages
                const isHttp = film.posterUrl && film.posterUrl.toLowerCase().startsWith('http:');
                const hasUrl = film.posterUrl && film.posterUrl.trim().length > 0;

                if (hasUrl && !isHttp) {
                    // C'est du HTTPS, on tente de l'afficher directement
                    imgTag = `<img src="${film.posterUrl}" alt="${film.title}" style="width: 100%; height: 100%; object-fit: cover;" onerror="tryTMDbPoster(this, '${film.title.replace(/'/g, "\\'")}', '${film.year}')">`;
                } else {
                    // C'est du HTTP ou vide : on met une image vide qui va d√©clencher onerror imm√©diatement pour appeler l'API
                    imgTag = `<img src="" alt="${film.title}" style="width: 100%; height: 100%; object-fit: cover;" onerror="tryTMDbPoster(this, '${film.title.replace(/'/g, "\\'")}', '${film.year}')">`;
                }

                return `
                <div class="film-card ${film.watched ? 'watched' : ''}"
                     onmouseenter="setCinemaHalo(this, '${bgColor[0]}')"
                     onmouseleave="resetCinemaHalo()"
                     onclick="openModal(${realIndex})">
                    <div class="film-poster" style="background: linear-gradient(135deg, ${bgColor[0]}, ${bgColor[1]});">
                        ${imgTag}
                    </div>
                    <div class="film-info-section">
                        <div class="watched-checkbox" onclick="event.stopPropagation()">
                            <input type="checkbox" id="checkbox-${realIndex}" ${film.watched ? 'checked' : ''} onchange="toggleWatched(${realIndex})">
                            <label for="checkbox-${realIndex}">Vu</label>
                        </div>
                        <div class="film-title">${film.title}</div>
                        <div class="film-info">
                            <div class="info-item">
                                <div class="info-label">Ann√©e</div>
                                <div class="info-value">${film.year}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Dur√©e</div>
                                <div class="info-value">${film.duration}</div>
                            </div>
                        </div>
                        ${film.genres.length > 0 ? `
                            <div class="genres">
                                ${film.genres.slice(0, 3).map(g => `<span class="genre-tag">${g}</span>`).join('')}
                                ${film.genres.length > 3 ? `<span class="genre-tag">+${film.genres.length - 3}</span>` : ''}
                            </div>
                        ` : ''}
                        
                        <div class="action-buttons">
                            <button onclick="event.stopPropagation(); checkJustWatch('${film.title.replace(/'/g, "\\'")}', ${film.year})" class="justwatch-btn">O√π Regarder</button>
                            <button onclick="event.stopPropagation(); deleteFilm(${realIndex})" class="delete-btn">‚úï</button>
                        </div>
                    </div>
                </div>
            `;
            }).join('');
        }

        function openModal(index) {
            const film = allFilms[index];
            const modal = document.getElementById('filmModal');
            const content = document.getElementById('modalCardContent');
            const bgColor = generateColorFromTitle(film.title);

            // M√™me logique que pour la liste : forcer l'API si HTTP
            const isHttp = film.posterUrl && film.posterUrl.toLowerCase().startsWith('http:');
            const hasUrl = film.posterUrl && film.posterUrl.trim().length > 0;
            
            let posterContent;
            if (hasUrl && !isHttp) {
                posterContent = `<img src="${film.posterUrl}" alt="${film.title}" style="width: 100%; height: 100%; object-fit: cover;" onerror="tryTMDbPoster(this, '${film.title.replace(/'/g, "\\'")}', '${film.year}')">`;
            } else {
                posterContent = `<img src="" alt="${film.title}" style="width: 100%; height: 100%; object-fit: cover;" onerror="tryTMDbPoster(this, '${film.title.replace(/'/g, "\\'")}', '${film.year}')">`;
            }

            const validAwards = film.awards.filter(a => !a.includes('http'));

            content.innerHTML = `
                <button class="modal-close" onclick="closeModal(event)">√ó</button>
                <div class="modal-poster" style="background: linear-gradient(135deg, ${bgColor[0]}, ${bgColor[1]});">
                    ${posterContent}
                </div>
                <div class="modal-info">
                    <h2 style="font-family:'Playfair Display', serif; font-size: 2.5em; color: #d4af37; margin-bottom: 10px;">${film.title}</h2>
                    <div style="color: #b8956a; font-size: 1.1em; margin-bottom: 20px;">
                        ${film.year} ‚Ä¢ ${film.duration} ${film.platform ? '‚Ä¢ ' + film.platform : ''}
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        ${film.genres.map(g => `<span class="genre-tag" style="font-size: 0.9em; padding: 6px 12px; margin-right: 8px;">${g}</span>`).join('')}
                    </div>

                    ${validAwards.length > 0 ? `
                        <div style="margin-bottom: 25px; background: rgba(212, 175, 55, 0.05); padding: 15px; border-radius: 4px; border: 1px solid rgba(212, 175, 55, 0.2);">
                            <h3 style="color: #d4af37; font-size: 0.9em; text-transform: uppercase; margin-bottom: 10px;">R√©compenses</h3>
                            <div class="awards">
                                ${validAwards.map(a => `<span class="award-badge" style="font-size: 0.8em;">üèÜ ${a}</span>`).join('')}
                            </div>
                        </div>
                    ` : ''}

                    <div style="margin-top: 30px; display: flex; gap: 15px;">
                        <button onclick="checkJustWatch('${film.title.replace(/'/g, "\\'")}', ${film.year})" class="justwatch-btn" style="padding: 15px 30px; font-size: 1em;">
                            üé• Voir les options de streaming
                        </button>
                    </div>
                </div>
            `;

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeModal(event) {
            if (event) event.stopPropagation();
            const modal = document.getElementById('filmModal');
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }

        // --- FILTRES ET UTILITAIRES ---

        function updateStats() {
            const watched = allFilms.filter(f => f.watched).length;
            const total = allFilms.length;
            const percentage = total > 0 ? Math.round((watched / total) * 100) : 0;
            
            document.getElementById('statsLeft').textContent = total + ' film' + (total > 1 ? 's' : '');
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressPercentage').textContent = percentage + '% compl√©t√©';
            document.getElementById('statsRight').textContent = watched + '/' + total + ' vus';
        }

        function filterFilms() {
            const title = document.getElementById('searchTitle').value.toLowerCase();
            const yearMin = document.getElementById('filterYearMin').value;
            const yearMax = document.getElementById('filterYearMax').value;
            const genre = document.getElementById('filterGenre').value.toLowerCase();
            const platform = document.getElementById('filterPlatform').value.toLowerCase();
            const durationMax = document.getElementById('filterDuration').value.trim();

            let filtered = allFilms.filter(film => {
                const matchTitle = film.title.toLowerCase().includes(title);
                
                let matchYear = true;
                const filmYear = parseInt(film.year);
                if (yearMin && filmYear < parseInt(yearMin)) matchYear = false;
                if (yearMax && filmYear > parseInt(yearMax)) matchYear = false;
                
                const matchGenre = !genre || film.genres.some(g => g.toLowerCase().includes(genre));
                const matchPlatform = !platform || film.platform.toLowerCase().includes(platform);
                
                let matchDuration = true;
                if (durationMax) {
                    const maxMinutes = convertToMinutes(durationMax);
                    const filmMinutes = convertToMinutes(film.duration);
                    if (filmMinutes === 0) matchDuration = true; // Si pas de dur√©e, on garde
                    else matchDuration = filmMinutes <= maxMinutes;
                }
                
                return matchTitle && matchYear && matchGenre && matchPlatform && matchDuration;
            });

            if (hideWatchedMode) filtered = filtered.filter(f => !f.watched);
            if (showOnlyWatchedMode) filtered = filtered.filter(f => f.watched);

            // Tri par ann√©e par d√©faut pour le r√©sultat filtr√©
            filtered.sort((a, b) => parseInt(b.year) - parseInt(a.year));
            displayFilms(filtered);
            updateStats();
        }

        function resetFilters() {
            document.querySelectorAll('.controls input').forEach(i => i.value = '');
            hideWatchedMode = false;
            showOnlyWatchedMode = false;
            
            const hideBtn = document.getElementById('hideWatchedBtn');
            const onlyBtn = document.getElementById('onlyWatchedBtn');
            
            if(hideBtn) { hideBtn.className = 'secondary'; hideBtn.textContent = 'üëÅÔ∏è Masquer Vus'; }
            if(onlyBtn) { onlyBtn.className = 'secondary'; onlyBtn.textContent = '‚úÖ Afficher Vus'; }
            
            allFilms.sort((a, b) => parseInt(b.year) - parseInt(a.year));
            displayFilms(allFilms);
            updateStats();
        }

        function getRandomFilm() {
            if (allFilms.length === 0) return alert('Aucun film dans la collection');
            const random = allFilms[Math.floor(Math.random() * allFilms.length)];
            displayFilms([random]);
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const newFilms = parseFilmsFromText(e.target.result);
                    if (newFilms.length === 0) return alert('Aucun film valide trouv√©');

                    let addedCount = 0;
                    let updatedCount = 0;

                    newFilms.forEach(newFilm => {
                        // On v√©rifie si le film existe d√©j√† (Titre + Ann√©e)
                        const existing = allFilms.find(f => f.title === newFilm.title && f.year === newFilm.year);
                        if (existing) {
                            // On met √† jour les infos mais on garde le statut "Vu"
                            const wasWatched = existing.watched;
                            Object.assign(existing, newFilm);
                            existing.watched = wasWatched;
                            updatedCount++;
                        } else {
                            allFilms.push(newFilm);
                            addedCount++;
                        }
                    });

                    resetFilters();
                    alert(`Import termin√© !\nüÜï ${addedCount} ajout√©s\nüîÑ ${updatedCount} mis √† jour`);
                    saveFilmsToStorage();
                    document.getElementById('fileInput').value = '';
                } catch (error) {
                    alert('Erreur lecture fichier: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // --- OUTILS ---

        function checkJustWatch(title, year) {
            // Cr√©ation d'un slug propre pour JustWatch
            let urlTitle = title.toLowerCase().trim()
                .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Enl√®ve les accents
                .replace(/[^a-z0-9\s-]/g, '') // Enl√®ve les caract√®res sp√©ciaux
                .replace(/\s+/g, '-') // Remplace les espaces par des tirets
                .replace(/-+/g, '-'); // √âvite les doubles tirets
            
            window.open(`https://www.justwatch.com/fr/recherche?q=${encodeURIComponent(title)}`, '_blank');
        }

        function convertToMinutes(duration) {
            if (!duration) return 0;
            const parts = duration.split(':');
            if (parts.length === 2) return parseInt(parts[0]) * 60 + parseInt(parts[1]);
            return parseInt(duration) || 0;
        }

        function toggleWatched(index) {
            allFilms[index].watched = !allFilms[index].watched;
            saveFilmsToStorage();
            updateStats();
            // On ne rafraichit la liste que si on est en mode filtre actif pour √©viter de perdre le scroll
            if (hideWatchedMode || showOnlyWatchedMode) filterFilms();
        }

        function deleteFilm(index) {
            if (confirm(`Supprimer "${allFilms[index].title}" ?`)) {
                allFilms.splice(index, 1);
                saveFilmsToStorage();
                filterFilms();
                alert('Film supprim√©.');
            }
        }

        function toggleHideWatched() {
            hideWatchedMode = !hideWatchedMode;
            showOnlyWatchedMode = false;
            
            const btn = document.getElementById('hideWatchedBtn');
            const onlyBtn = document.getElementById('onlyWatchedBtn');
            
            btn.className = hideWatchedMode ? '' : 'secondary';
            btn.textContent = hideWatchedMode ? 'üëÅÔ∏è Afficher Tous' : 'üëÅÔ∏è Masquer Vus';
            
            onlyBtn.className = 'secondary';
            onlyBtn.textContent = '‚úÖ Afficher Vus';
            
            filterFilms();
        }

        function toggleShowOnlyWatched() {
            showOnlyWatchedMode = !showOnlyWatchedMode;
            hideWatchedMode = false;
            
            const btn = document.getElementById('onlyWatchedBtn');
            const hideBtn = document.getElementById('hideWatchedBtn');
            
            btn.className = showOnlyWatchedMode ? '' : 'secondary';
            btn.textContent = showOnlyWatchedMode ? '‚úÖ Afficher Tous' : '‚úÖ Afficher Vus';
            
            hideBtn.className = 'secondary';
            hideBtn.textContent = 'üëÅÔ∏è Masquer Vus';
            
            filterFilms();
        }

        function removeDuplicates() {
            const seen = new Set();
            const uniqueFilms = [];
            let duplicateCount = 0;

            allFilms.forEach(film => {
                const key = `${film.title}|${film.year}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueFilms.push(film);
                } else {
                    duplicateCount++;
                }
            });

            allFilms = uniqueFilms;
            saveFilmsToStorage();
            resetFilters();
            alert(`‚úî ${duplicateCount} doublons supprim√©s.`);
        }

        function goHome() {
            resetFilters();
            window.scrollTo(0, 0);
        }

        function sortAlphabetically() {
            allFilms.sort((a, b) => a.title.localeCompare(b.title, 'fr'));
            displayFilms(allFilms);
        }

        function sortByYear() {
            allFilms.sort((a, b) => parseInt(b.year) - parseInt(a.year));
            displayFilms(allFilms);
        }

        // G√©n√®re un d√©grad√© de couleur unique bas√© sur le titre du film
        function generateColorFromTitle(title) {
            let hash = 0;
            for (let i = 0; i < title.length; i++) {
                hash = title.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            const colors = [
                ['#3b82f6', '#1e40af'], ['#8b5cf6', '#5b21b6'], ['#ec4899', '#be185d'],
                ['#10b981', '#065f46'], ['#f59e0b', '#92400e'], ['#ef4444', '#7f1d1d'],
                ['#06b6d4', '#0c4a6e'], ['#6366f1', '#312e81'], ['#14b8a6', '#134e4a'],
                ['#d946ef', '#581c87'], ['#ea580c', '#7c2d12'], ['#0891b2', '#164e63'],
                ['#7c3aed', '#4c1d95'], ['#059669', '#064e3b']
            ];
            
            return colors[Math.abs(hash) % colors.length];
        }

        // Effet de halo dynamique au survol
        function setCinemaHalo(card, color) {
            const bg = document.getElementById('dynamic-bg');
            const rect = card.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;

            bg.style.opacity = '1';
            bg.style.background = `radial-gradient(circle at ${x}px ${y}px, ${color}66 0%, transparent 85%)`;
        }

        function resetCinemaHalo() {
            const bg = document.getElementById('dynamic-bg');
            bg.style.opacity = '0.5';
            bg.style.background = `radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%)`;
        }

        // Initialisation
        window.addEventListener('DOMContentLoaded', function() {
            loadFilmsFromStorage();
            
            // Events listeners pour les filtres (touche Entr√©e)
            const inputs = ['searchTitle', 'filterYearMin', 'filterYearMax', 'filterGenre', 'filterPlatform', 'filterDuration'];
            inputs.forEach(id => {
                document.getElementById(id).addEventListener('keypress', e => {
                    if (e.key === 'Enter') filterFilms();
                });
            });
            
            document.addEventListener('keydown', function(event) {
                if (event.key === "Escape") closeModal();
            });
        });
    </script>
